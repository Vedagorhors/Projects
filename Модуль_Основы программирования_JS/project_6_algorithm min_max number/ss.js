/* Алгоритм нахождения минимального и максимального числа из массива чисел. 
Представим, что массив - это библиотека, в которой есть какое-то количество книг. В каждой книге записано некое число.
Нужно найти минимальное и максимальное число, указанное в книгах.
1 Беру книгу, смотрю в ней записанное число и запоминаю его.
2 По очереди беру следующую книгу, смотрю число, записанное в ней и сравниваю с числом, записанным в предыдущей книге,
если число, записанное в следующей книге, меньше числа из предыдущей книги, то запомниаю уже это число, вместо прошлого 
и так сравниваю все книги

Применительно к скрипту: книга с числом это array[i]
*/

// const array = [17, 12, 54, 90, 10, 2, 25, 93, 83, 15];
// let min = array[0];
// Беру первую книгу array[0] и запоминаю число (17), записанное в ней (объявляю и определяю переменную).
// Индексы в массиве начинаются с 0.
// let max = array[0]; // Также создаю переменную для опредения максимального числа, заипсывая в неё значение число первой книги (17)
// for (let i = 1; i < array.length; i++) {
//  Буду перебирать по очереди всю стопку книг с помощью цикла.
//   Так как первую книгу я уже взял (array[0]),
//   беру следующую книгу с числом (array[i]). Делаю инициализацию цикла i = 0,
//   задаю условие циклу, буду брать книги пока они не закончатся, пока i будет меньше
//   длины массива (количества книг в стопке). i++ задаю шаг, то есть буду брать только
//   по одной книге
//  const book = array[i];
// Объявлю и определю переменную book, то есть запомню следующую книгу с числом, чтобы было удобнее сравнивать
//  в операторе условия if, хотя в данном случае переменную можно и не создавать, а использовать array[i]
// if (book < min) {
// сравниваю число, записанное во вновь взятой книге с минимальным на тот момент числом, записанным в
//                         предыдущей книге,
// min = book;
// }
// \если число, записанное во вновь взятой (следующей) книге, меньше числа из предыдущих книг,
//  то запоминиаю уже это число, вместо прошлого, если нет, то оставляю в переменной ранее записанное число
//  (т.е. ничего не делаю) и так сравниваю все книги с помощью цикла for
// Таким образом пересмотрев все книги и сравнив числа, при этом каждый раз запоминая вместо запомненного,
// ещё более меньшее число я вычисляю самое минимальное число */
// if (book > max) {
// По такому же алгоритму вычисляю и самое максимальное число, только смотрю больше ли число из вновь взятой
// книги запомненного максимального числа из предыдущих книг */
// max = book;
// }
// }
// console.log(min);
// console.log(max);

// Тот же скрипт без комментариев
const array = [17, 12, 54, 90, 10, 2, 25, 93, 83, 15];
let min = array[0];
let max = array[0];
for (let i = 1; i < array.length; i++) {
  const book = array[i];
  if (book < min) {
    min = book;
  }

  if (book > max) {
    max = book;
  }
}
console.log(min); // 2
console.log(max); // 93

/* Второй вариант, когда книгу беру я первый раз let min = array[0] 
и потом в цикле робот берёт книги снова начиная с первой книги i = 0 */

// const array = [17, 12, 54, 90, 10, 2, 25, 93, 83, 15];
// let min = array[0];
// let max = array[0];
// for (let i = 0; i < array.length; i++) {
//   const book = array[i];
//   if (book < min) {
//     min = book;
//   }

//   if (book > max) {
//     max = book;
//   }
// }
// console.log(min); // 2
// console.log(max); // 93

// Память O(const)
// Скорость O(n)

// Определение суммы всех чисел в массиве
// const array = [17, 12, 54, 90, 10, 2, 25, 93, 83, 15];

// let sum = 0;
// for (let i = 0; i < array.length; i++) {
//   sum += array[i];
// }
// console.log(sum);

// Память O(const)
// Скорость O(n)
