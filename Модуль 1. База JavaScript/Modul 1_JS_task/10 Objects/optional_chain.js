// Опциональная цепочка.txt

// При попытке обращения к свойствам вложенных объектов может случиться так, что сам вложенный объект не существует
// (то есть равен undefined или null). При этом будет выброшена ошибка. В следующем примере допустим,
// что мы закомментировали вложенный объект owner, забыли об этом и попытались обратиться к его свойству name:

const car = {
  name: "Toyota Corolla",
  // owner: {
  //   name: "Ivanov Ivan"
  // }
};

console.log(car.owner.name); // Ошибка
// При попытке доступа к свойству несуществующего объекта будет выброшена ошибка Uncaught TypeError:
//  Cannot read properties of undefined (пытаемся получить свойство у undefined).
// Избежать её можно, добавив проверку существования объекта, к свойству которого мы обращаемся:

const car = {
  name: "Toyota Corolla",
  // owner: {
  //   name: "Ivanov Ivan"
  // }
};

if (car.owner) {
  // Не выполнится и ошибки не будет
  console.log(car.owner.name);
}

// Опциональная цепочка

// Рассмотрим немного более сложный пример. У нас есть объект машины car со вложенным объектом владельца машины owner,
// внутрь которого вложен ещё один объект — документ владельца машины document:

const car = {
  name: "Toyota Corolla",
  owner: {
    name: "Ivanov Ivan",
    document: {
      type: "Passport",
      number: "123 456",
    },
  },
};
// По каким-то причинам у нас может не быть уверенности, что сам объект или вложенные в него объекты существуют.
// Например, пользователь еще не заполнил информацию о документах, а мы уже пытаемся её получить.
// При работе с таким объектом важно удостовериться, что все родительские объекты нужных нам свойств существуют:

if (car && car.owner && car.owner.document) {
  // Можно обращаться к свойствам внутри document
}
// Однако такие проверки могут быть достаточно длинными и не очень удобными для чтения.
// Упростить запись можно с помощью оператора опциональной цепочки ?.:

if (car?.owner?.document) {
  // Можно обращаться к свойствам внутри document
}
// Такая запись по смыслу аналогична предыдущему варианту проверки, но существенно короче.
// Если один из объектов перед оператором ?. не существует, будет возвращено значение undefined.
// Таким образом, условие не сработает и наш код окажется защищённым от ошибок.

// Аналогичным образом можно использовать опциональную цепочку при получении значений свойств и обращении к методам объектов:

const car = {
  name: "Toyota Corolla",
  year: 2017,
  owner: {
    name: "Ivanov Ivan",
  },
  getInfo() {
    // С ключевым словом this поработаем в следующих уроках
    console.log(`Car name: ${this.name}, year: ${this.year}`);
  },
};

// Безопасное получение значения свойства
const ownerName = car?.owner?.name;

// Безопасный вызов метода объекта
car?.getInfo?.();
// Опциональная цепочка — полезная возможность, однако не стоит использовать её везде, а только там,
// где действительно есть вероятность встретить несуществующий объект.

// Итоги

// В этом уроке мы разобрали особенности работы с объектами в JavaScript:

// Создание объектов и работа с их свойствами: определение свойств, изменение и удаление.
// Отличия между примитивными и ссылочными типами данных.
// Перебор свойств объекта с помощью цикла for...in и функций Object.keys(), Object.values(), Object.entries().
// Создание уникальных ключей объектов с помощью Symbol.
// Объединение объектов с помощью spread-оператора ... и функции Object.assign().
// Использование опциональной цепочки .? для решения проблемы несуществующего объекта.
