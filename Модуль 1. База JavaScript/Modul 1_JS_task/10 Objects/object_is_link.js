// Всего 8 типов данных
// 7 типов это примитивы (не ссылочный тип данных)
// 1 тип object - не примитив (ссылочный тип данных). Массивы это тоже объекты

const setName = (entity, value) => {
  if (typeof entity === "object") {
    entity.name = value;
  } else {
    entity = value;
  }
};

const developer = {
  name: "Maxim",
};

let developerName = "Maxim";

setName(developer, "Max");
setName(developerName, "Max");

// console.log("developer", developer);
// console.log("developerName", developerName);

console.log({} === {}); // false, потому что здесь сравниваются разные ссылочные значения
console.log([] === []); // false, потому что здесь сравниваются разные ссылочные значения
// чтобы сравнивание объектов выводило true нам нужно сравнивать не сами объекты,  а их ссылки

const entity = {};
const entityCopy = entity; // ссылку на объект, хранящуюся в переменной entity скопировал в новую переменную entityCopy
console.log(entity === entityCopy); // true, потому что сравниваем ссылочные значения,
// то есть здесь entity хранит ссылку на entityCopy, а эти ссылки одинаковы, равны
// можно применять const, так как мы не меняем саму переменную хранящей ссылку на объект, а мы меняем сам объект,
// хранящийся в другой области памяти, а не в это же переменной

// у примитивов нет ссылок
console.log("hello" === "hello"); // true
console.log(5 === 5); // true

// Передача объекта в функцию

// Проиллюстрируем разницу между примитивными и ссылочными типами на примере функций.
// Попробуем обновить сначала значение примитивного типа, переданное в функцию:

const x = 10;
const updateX = (arg) => (arg = 20);
updateX(x);

console.log(x); // 10
// Здесь переменная x передается в стрелочную функцию updateX(), которая присваивает полученному аргументу значение 20.
// После этого значение переменной x выводится в консоль, и мы видим, что оно не изменилось. Здесь работает тот же принцип,
// что и при создании копии переменной. При передаче переменной примитивного типа в качестве аргумента, копируется её значение.
// То есть создается новая переменная, которая никак не зависит от первоначальной.

// Попробуем передать в функцию объект и обновить значение его свойства:

const obj = { x: 10 };
const updateObjX = (arg) => (arg.x = 20);
updateObjX(obj);

console.log(obj.x); // 20
// После обновления свойства x внутри функции updateObjX обновилось также значение этого свойства внутри оригинального объекта.
// Таким образом, объект передается по ссылке.
