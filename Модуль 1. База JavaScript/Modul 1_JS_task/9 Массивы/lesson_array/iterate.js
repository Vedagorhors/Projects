// Итарации в циклах
const developerNames = ["Maxim", "Igor", "Nastya", "Irina"];

for
console.log(developerNames[1]); // Igor
console.log(developerNames[100]); // undefined, такое значение под индексом 100 не существует

for (let i = 0; i < developerNames.length; i += 1) {
  console.log("i", i);
  console.log("item", developerNames[i]); // выводит все элементы имена в массиве
}

const array = ["Java", "Script", "Hello", "World"];
for (let i = 0; i < array.length; i++) {
  console.log("array item:", array[i]);
}

/*
  Вывод:
  array item: 'Java'
  array item: 'Script'
  array item: 'Hello'
  array item: 'World'
*/

// Цикл for of  для перебирания элементов массива
for (значение of массив) {
  // тело
}

// Значение. В этом месте мы задаем переменную, которая будет принимать значение каждого элемента массива по порядку.
// Массив. Здесь мы задаем массив, из которого будут браться значения для нашей переменной.
// Тело. В теле цикла мы прописываем всю логику, которая будет выполняться над каждым элементом массива.
// Давайте посмотрим, как в данном случае выглядит перебор массива:

const array = ["one", "two", "three", "four", "five"];
for (const item of array) {
  console.log("array item:", item);
}

/*
  Вывод:
  array item: one
  array item: two
  array item: three
  array item: four
  array item: five
*/

for (const name of developerNames) {
  console.log("name", name);
}

// forEach - это метод массива, более современный цикл, именно его рекомендуют использовать для массивов. Выглядит так: array.forEach();

// Структура данного метода:

array.forEach((элемент, индекс, массив) => {
  // тело функции
});

// Метод forEach() принимает в себя функцию-callback. Callback - это функция, которая передается в другую функцию.
// В свою очередь, функция принимает в себя три параметра:
// Элемент. Данный параметр принимает в себя, непосредственно, значение каждого элемента массива по порядку.
// Индекс. Данный параметр является опциональным (необязательным) и принимает в себя индекс текущего элемента массива.
// Массив. Данный параметр также является опциональным и каждый раз принимает в себя текущий массив.
// Тело функции. В данном месте мы прописываем всю необходимую логику. Она будет выполняться для каждого элемента массива.
// Давайте посмотрим, как это выглядит на практике:

const array = [1, "two", true, false];
array.forEach((item, index, array) => {
  console.log("array item:", item);
  console.log("item index:", index);
  console.log("array:", array);
});

/*
  Вывод:
  array item: 1
  item index: 0
  array: [1, 'two', true, false]

  array item: 'two'
  item index: 1
  array: [1, 'two', true, false]

  array item: true
  item index: 2
  array: [1, 'two', true, false]

  array item: false
  item index: 3
  array: [1, 'two', true, false]
*/

// developerNames.forEach(function () {}); // цикл принимает в себя в качестве параметра вложенную функцию callback

// цикл принимает в себя в качестве параметра вложенную функцию callback. Лучше использовать форму стрелочной функции:
developerNames.forEach((name, index, array) => {
  //   console.log("name", name);
  //   console.log("index", index);
  console.log("array", array);
});

// map - метод, функция. Принимает в себя функцию callback. map используется, чтобы применять действия к каждому элементу массива
// map возвращает новый массив (поэтому присвоим его переменной), а текущий остается без изменения
const salariesOfDevelopers = [400, 500, 600, 2000, 350];
const updatedSalaries = salariesOfDevelopers.map((salery, index, array) => {
  return salery * 2;
});
console.log("updatedSalaries", updatedSalaries); // все элементы salery умножились на 2 [800, 1000, 1200, 4000, 700]

// filter - метод. Принимает в себя функцию callback. filter используется фильтрования массива по условию
const filteredSalaries = salariesOfDevelopers.filter((salery, index, array) => {
  return salery > 600;
  // выведем зарплаты у которых индекс является четным return index % 2 === 0;
});
console.log("filteredSalaries", filteredSalaries);

// find - метод, функция. Принимает в себя функцию callback. find ищет элемент в массиве по условию. Не изменяет текущий массив
const searchedSalary = salariesOfDevelopers.find((salary) => {
  return salary === 500;
  // если ввести не существующий в массиве элемент, например 700, то выведется undefined
  // если задать условие, например, salary > 500, то под это условие подпадает несколько элементов, но выведется только первый попавшийся
  // удовлетворяющий условию, начиная с нулевого индекса (первый элемент)
});
// если мы не используем второй и третий параметры функции (, index, array), то их можно не вписывать
console.log("searchedSalary", searchedSalary); // searchSalary 500

// findIndex - метод, функция. Работает так же как  find, только возвращает не элемент, а индекс находит запрашиваемый
// будем рабоnать в данном случае только с элементами массива, но findIndex принимает также и остальные параметры,
// как и все методы из данного урока, а именно (salery, index, array), но мы можем их не вписывать, если они не нужны
const searchedIndex = salariesOfDevelopers.findIndex((salary) => {
  return salary === 400;
});
console.log("searchedIndex", searchedIndex); // 0 - индекс элемента 400
// Данный метод возвращает индекс первого найденного элемента массива, которое удовлетворяет условию. Если такой элемент не был найден, вернется -1.
// если ввести не существующий элемент в массиве, то метод вернет -1, что значит элемент не найден, то есть такого элемента нет

const array = [10, 120, 50, 60, 600, 500];

const foundIndex1 = array.findIndex((item) => {
  return item > 100;
});
console.log("found index 1: ", foundIndex1); // 1

const foundIndex2 = array.findIndex((item) => {
  return item === 0;
});
console.log("found index 2: ", foundIndex2); // -1

// some - метод, функция. some  возвращает true  либо false. some смотрит, если хотя бы один элемент в массиве удовлетворяет нашему условию,
// тогда наша переменная elementExists будет true иначе, если ни один элемент не удовлетворяет условию, то elementExists будет false
const elementExists = salariesOfDevelopers.some((salary) => {
  return salary > 1000;
});
console.log("elementExists", elementExists); // true

// every метод, функция - возращает true, когда все элементы массива удовлетворяют нашему условию иначе false
const allElementExists = salariesOfDevelopers.every((salary) => {
  return salary > 0;
});
console.log("allElementExists", allElementExists); // true. allElementExists будет true  так как все элементы массива удовлетворяют условию salary > 0


// reduce - метод, функция
/* Метод reduce() принимает в себя два параметра:

Функцию-callback, которая, в свою очередь, принимает в себя четыре параметра:
Аккумулятор. Он равен “начальному значению” при первом вызове функции, либо первому элементу массива,
 если “начальное значение” не задано. При последующих вызовах он равен результату предыдущего вызова функции.
Элемент - текущий элемент массива.
Индекс - индекс текущего элемента массива. Необязательный параметр.
Массив - текущий массив. Также является необязательным параметром.
Начальное значение - значение, которое будет задано аккумулятору перед первым вызовом функции.
Является необязательным параметром. Если он не задан, тогда аккумулятору присвоится значение первого элемента массива.
Тело функции. В нем мы прописываем всю необходимую логику */
// Метод reduce() используется для вычисления единого значения на основе всего массива. 
// То есть, например, для вычисления суммы элементов массива.

// структура:
const value = array.reduce((аккумулятор, элемент, индекс, массив) => {
  // тело функции
}, начальное значение)

// acc - аккумулятор с начлаьным значением 0, кторый мы передаем вторым аргументом  
// const salariesOfDevelopers = [400, 500, 600, 2000, 350]; // закоментил, так как он есть выше
salariesOfDevelopers((acc, salary, index, array) => {
    console.log('acc', acc);
    return 1;
}, 0);
// если убрать 0 и return 1, то начальный параметр будет первый элемент в массиве, в данном случае 400
salariesOfDevelopers.reduce((acc, salary, index, array) => {
    console.log('acc', acc);
});
// если вернуть return 1, то первый аргумент будет 400, а остальные равны 1
 salariesOfDevelopers.reduce((acc, salary, index, array) => {
     console.log('acc', acc);
    return 1
});
// вычисляем сумму значений массива
const sum = salariesOfDevelopers.reduce((acc, salary, index, array) => {
    console.log('acc/salary', acc, salary);
    return acc + salary; // 0 + 400, затем acc уже равно этой сумме 400, 400 + 500, затем 900 + 600, 1500 +2000, 3500 + 350 = 3850
});
console.log('sum', sum); // sum 3850

// Давайте посмотрим, как работает данный метод:

const array = [10, 120, 50, 60, 600, 500];
const sum = array.reduce((acc, item) => {
  return acc += item;
}, 0);
console.log('sum:', sum); // 1340

// запишем проще, используя сокращенную запись arrow функции:
const array = [10, 120, 50, 60, 600, 500];
const sum = array.reduce((acc, item) => acc += item, 0);
console.log('sum:', sum); // 1340

// С помощью данного метода мы посчитали сумму элементов массива. 
// Мы задали аккумулятору acc начальное значение, равное 0 и в теле функции каждый раз увеличивали аккумулятор на значение,
//  равное текущему элементу массива - item.

// К одному массиву можно применять эти методы по цепочке, это называетйся чэин
// const sum = array.reduc...
//                  .map...
//                  .filter...


// sort - метод, функция - для сортировки массива. sort  изменяет текущий массив, в отличие от других методов, 
// которые возвращают новый массив, а исходный оставляет без изменений
// const salariesOfDevelopers = [400, 500, 600, 2000, 350]; // закоментил, так как он есть выше
// Чтобы отсортировать массив по числам, необходимо передавать функцию callback
// a и b это два элемента нашего массива
// сортировка чисел по возрастанию a - b
salariesOfDevelopers.sort((a, b) => {
    return a - b;
});
console.log('salariesOfDevelopers', salariesOfDevelopers);

// сортировка чисел по убыванию b - a
salariesOfDevelopers.sort((a, b) => {
    return b - a;
});
console.log('salariesOfDevelopers', salariesOfDevelopers);

// отсоритуем имена, строки сравниваются по коду символа
// если применять метод без параметров, то он и числа массива будет сравнивать как строки

// Метод sort() работает по следующему принципу:
// sort() должен вернуть значение меньше нуля, равное нулю или больше нуля.
// Если вернется значение меньше нуля, сортировка поставит a по меньшему индексу, чем b, то есть, a будет идти первым.
// Если вернется значение больше нуля, сортировка поставит b по меньшему индексу, чем a, то есть, b будет идти первым.
// Если вернётся значение равное нулю, сортировка оставит a и b неизменными по отношению друг к другу.

// сортировка массива строк по возрастанию, для этого не нужно передавать callback
const developerNames = ["Maxim", "Igor", "Nastya", "Irina"]; 
developerNames.sort();
console.log('developerNames', developerNames); // отсортирует по величине кодов символов строк, на возрастанию
// если же нужно сортировать по убыванию, то нужно передеавать функцию callback
// a и b это два элемента нашего массива

// сортировка по возрастанию строк
developerNames.sort((a, b) => {
    if (a > b) {
    return 1;
}
if (a < b) {
    return -1;
}
return 0;
});

// сортировка по убыванию. Меняем знак > на <
developerNames.sort((a, b) => {
    if (a < b) {
    return 1;
}
if (a > b) {
    return -1;
}
return 0;
});

// Если говорить о сортировке чисел, то с ними все проще:

const array = [2, 4, 1, 3, 7, 6, 5];
array.sort((a, b) => {
  return a - b;
});
console.log(array); // [1, 2, 3, 4, 5, 6, 7]

// Метод sort() работает все по тому же принципу. Функция вернет число, которое может быть больше нуля, 
// меньше нуля или равное нулю. Если вернется значение меньше нуля, тогда сортировка поставит a перед b. 
// Если больше нуля, то наоборот. А если вернется значение, равное нулю, числа останутся на своих местах. 
// В результате он отсортировал наш массив по возрастанию.

// Разберем как он действует на примере первых элементов: 

// Сперва переменной a присвоится значение 4, а переменной b - значение 2. a - b (4 - 2) в таком случае 
// будет равно 2 - положительное значение. Следовательно, b со значением 2 будет идти раньше, чем a.
// Дальше переменной a присвоится значение 1, а переменной b - значение 4. В этом случае a - b (1 - 4) 
// будет равно -3 - отрицательное значение. Следовательно, a будет идти раньше, чем b.
// Теперь метод sort() видит, что первые элементы, которые он перебирал, до сих пор не идут в том порядке,
//  который нужен (Сейчас порядок такой: 2, 1, 4,...). Тогда он присваивает переменной a значение 1, а переменной b - значение 2.
//  В таком случае a - b будет равно -1 - отрицательное значение. Соответственно, a будет идти раньше b. 
// В итоге порядок будет такой: 1, 2, 4,....
// Далее он перейдет к следующим элементам и будет сортировать их по такой же схеме.
// Чтобы отсортировать этот же массив по убыванию, достаточно поменять переменные местами. 
// В таком случае положительные значения, которые мы получали в прошлом примере, станут отрицательными, а отрицательные - положительными:

const array = [2, 4, 1, 3, 7, 6, 5];
array.sort((a, b) => {
  return b - a;
});
console.log(array); // [7, 6, 5, 4, 3, 2, 1]

// Массив отсортирован в порядке убывания.

// Снова разберем как он действует на примере первых элементов:

// Сперва переменной a присвоится значение 4, а переменной b - значение 2. b - a (2 - 4) в таком случае будет равно -2 - отрицательное значение. Следовательно, a со значением 4 будет идти раньше, чем b.
// Дальше переменной a присвоится значение 1, а переменной b - значение 4. В этом случае b - a (4 - 1) будет равно 3 - положительное значение. Следовательно, b будет идти раньше, чем a. Сейчас порядок следующий: 4, 2, 1,....
// Далее он перейдет к следующим элементам и будет сортировать их по такой же схеме.


